/**
 * Agentic Design System — Token Resolution Engine
 *
 * Stack-agnostic token resolver that transforms DTCG-format design tokens
 * into platform-specific outputs (CSS custom properties, JSON, etc.)
 *
 * This is the core engine that any framework integration would wrap.
 */

const fs = require('fs');
const path = require('path');

class TokenEngine {
  constructor() {
    this.tokens = {};
    this.resolved = {};
    this.themes = { light: {}, dark: {} };
  }

  /**
   * Load a DTCG-format token file and merge into the token dictionary
   */
  load(filePath) {
    const raw = JSON.parse(fs.readFileSync(filePath, 'utf8'));
    this.tokens = this._deepMerge(this.tokens, raw);
    return this;
  }

  /**
   * Resolve all token references (e.g., "{color.primitive.blue.600}" → "#228BE6")
   */
  resolve() {
    this.resolved = this._resolveObject(this.tokens, this.tokens);
    return this;
  }

  /**
   * Generate CSS custom properties
   */
  toCSS(options = {}) {
    const { prefix = 'ads', selector = ':root' } = options;
    const flatTokens = this._flatten(this.resolved);

    const lines = [`${selector} {`];
    for (const [tokenPath, value] of Object.entries(flatTokens)) {
      if (tokenPath.startsWith('$')) continue; // skip metadata
      const cssVar = `--${prefix}-${tokenPath.replace(/\./g, '-')}`;
      lines.push(`  ${cssVar}: ${this._toCSSValue(value)};`);
    }
    lines.push('}');
    return lines.join('\n');
  }

  /**
   * Generate a flat JSON map for any platform
   */
  toFlatJSON() {
    return this._flatten(this.resolved);
  }

  /**
   * Generate TypeScript type definitions for token paths
   */
  toTypeScript(options = {}) {
    const { typeName = 'DesignToken' } = options;
    const flatTokens = this._flatten(this.resolved);
    const paths = Object.keys(flatTokens).filter(k => !k.startsWith('$'));

    const lines = [
      `// Auto-generated by Agentic Design System Token Engine`,
      `// Do not edit manually`,
      ``,
      `export type ${typeName} =`,
      ...paths.map((p, i) => `  | '${p}'${i === paths.length - 1 ? ';' : ''}`),
      ``,
      `export declare function token(path: ${typeName}): string;`,
    ];
    return lines.join('\n');
  }

  // --- Internal helpers ---

  _resolveObject(obj, root) {
    if (typeof obj !== 'object' || obj === null) return obj;

    // If this is a token leaf node (has $value)
    if (obj.$value !== undefined) {
      return {
        ...obj,
        $value: this._resolveValue(obj.$value, root),
      };
    }

    // Otherwise, recurse
    const result = {};
    for (const [key, val] of Object.entries(obj)) {
      result[key] = this._resolveObject(val, root);
    }
    return result;
  }

  _resolveValue(value, root) {
    if (typeof value === 'string' && value.startsWith('{') && value.endsWith('}')) {
      const refPath = value.slice(1, -1);
      const referenced = this._getByPath(root, refPath);
      if (referenced && referenced.$value !== undefined) {
        // Recursively resolve in case of chained references
        return this._resolveValue(referenced.$value, root);
      }
      return value; // unresolved reference
    }
    if (typeof value === 'object' && value !== null) {
      // Composite token (e.g., typography)
      const resolved = {};
      for (const [k, v] of Object.entries(value)) {
        resolved[k] = this._resolveValue(v, root);
      }
      return resolved;
    }
    return value;
  }

  _getByPath(obj, dotPath) {
    return dotPath.split('.').reduce((acc, key) => acc && acc[key], obj);
  }

  _flatten(obj, prefix = '', result = {}) {
    for (const [key, val] of Object.entries(obj)) {
      if (key.startsWith('$') && prefix === '') continue; // skip top-level metadata

      const newPrefix = prefix ? `${prefix}.${key}` : key;

      if (val && typeof val === 'object' && val.$value !== undefined) {
        result[newPrefix] = val.$value;
      } else if (val && typeof val === 'object' && !val.$value) {
        this._flatten(val, newPrefix, result);
      } else {
        result[newPrefix] = val;
      }
    }
    return result;
  }

  _toCSSValue(value) {
    if (typeof value === 'string') return value;
    if (typeof value === 'number') return `${value}`;
    if (Array.isArray(value)) {
      // Shadow arrays
      return value.map(s =>
        `${s.offsetX} ${s.offsetY} ${s.blur} ${s.spread} ${s.color}`
      ).join(', ');
    }
    if (typeof value === 'object') {
      // Composite — return as CSS comment placeholder
      return `/* composite: ${JSON.stringify(value)} */`;
    }
    return String(value);
  }

  _deepMerge(target, source) {
    const result = { ...target };
    for (const key of Object.keys(source)) {
      if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
        result[key] = this._deepMerge(result[key] || {}, source[key]);
      } else {
        result[key] = source[key];
      }
    }
    return result;
  }
}

// --- CLI entry point ---
if (require.main === module) {
  const engine = new TokenEngine();
  const tokensDir = __dirname;

  // Load all token files
  const tokenFiles = fs.readdirSync(tokensDir)
    .filter(f => f.endsWith('.tokens.json'));

  for (const file of tokenFiles) {
    console.log(`Loading: ${file}`);
    engine.load(path.join(tokensDir, file));
  }

  engine.resolve();

  // Output CSS
  const css = engine.toCSS();
  const outputPath = path.join(tokensDir, '..', 'docs', 'tokens.css');
  fs.writeFileSync(outputPath, css);
  console.log(`\nCSS custom properties written to: ${outputPath}`);
  console.log(`Total properties: ${css.split('\n').length - 2}`);

  // Output flat JSON
  const json = engine.toFlatJSON();
  const jsonPath = path.join(tokensDir, '..', 'docs', 'tokens.resolved.json');
  fs.writeFileSync(jsonPath, JSON.stringify(json, null, 2));
  console.log(`Resolved tokens written to: ${jsonPath}`);
}

module.exports = { TokenEngine };
